### Codecademy

#### Constants

`FOUR = 4`
Constant variables (which do not change) are denoted in ALL CAPS

#### times method

    10.times { puts "This will be printed 10 times" }

#### !

! at the end of a method usually means modify the original instead of returning a copy

#### Ternary expressions

puts x < y ? "#{x} is less than #{y}" : "#{x} is not less than #{y}"

#### case statements

    puts "Input command:"
    command = gets.chomp.downcase

    case command
      when "add"
        #add something to data structure
      when "remove"
        #remove something from data structure
      else
        puts "command not recognised"

#### conditional assignment

#### implicit return

#### respond_to? method

#### << push/concatenate

#### .collect

essentially python map (but returns copy) or list comp
equivalent to ruby .map

#### .select

essentially equivalent to python filter or list comp
returns selection from iterable that matches condition

        my_array = ["raindrops", :kettles, "whiskers", :mittens, :packages]
        symbol_filter = lambda { |x| x.is_a? Symbol }
        symbols = my_array.select(&symbol_filter)
        puts symbols

#### symbols

      .to_sym
      .intern

- you can pass a ruby method as a symbol
- method names are symbols
- these two ways of defining a method are equivalent

      class Foo
        def bar
          puts "hello"
        end
      end

      class Foo
        define_method(:bar) do
          puts "hello"
        end
      end

- can use & to convert symbol to proc

      numbers_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      strings_array = numbers_array.map(&:to_s)
      puts strings_array
      # => ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

#### blocks

- basically sad lambda expressions..?

      do
      end

      {}

      def double(n)
        yield n
      end

      puts double(10) { |x| x * 2 }

- you can have a double function that yields to (essentially) a lambda that does the actual doubling for you??
- what the fuck

#### proc

- a proc is a "saved block"

      cube = Proc.new { |x| x**3 }
      [1, 2, 3].each.map(&cube)

- can .call a proc

      hi = Proc.new { |name| puts "Hello #{name}!" }
      hi.call("Daniel")
      # => Hello Daniel!

#### Lambdas

- just a weird proc
  `lambda { puts "Hello" }` ~= `Proc.new { puts "Hello" }`

##### Lambdas vs Procs

- A lambda checks the number of arguments passed to it, proc does not
- Lambda will throw an error if wrong number of arguments are passed to it
- A proc will ignore extra args and assign nil to missing args.

      p = Proc.new {|a, b| puts a**2+b**2 } # => #<Proc:0x3c7d28@(irb):1>
      p.call 1, 2 # => 5
      p.call 1 # => NoMethodError: undefined method `**' for nil:NilClass
      p.call 1, 2, 3 # => 5
      l = lambda {|a, b| puts a**2+b**2 } # => #<Proc:0x15016c@(irb):5 (lambda)>
      l.call 1, 2 # => 5
      l.call 1 # => ArgumentError: wrong number of arguments (1 for 2)
      l.call 1, 2, 3 # => ArgumentError: wrong number of arguments (3 for 2)

- A lambda will return only within the scope of the calling function (like python)
- A proc will also return from the enclosing method

      def my_proc_method
        puts "before proc"
        my_proc = Proc.new do
          puts "inside proc"
          return
        end
        my_proc.call
        puts "after proc"
      end

      my_proc_method
      # => before proc
      # => inside proc

"after proc" is not printed, because proc returns from both my_proc.call and my_method

      def my_lambda_method
        puts "before lambda"
        my_lambda = lambda do
          puts "inside lambda"
          return
        end
        my_lambda.call
        puts "after lambda"
      end

      my_lambda_method
      # => before lambda
      # => inside lambda
      # => after lambda

"after lambda" is printed.

### Intro to Programming with Ruby

#### Remainder vs modulo (%)

| a   | b   | a/b  | floor | a % b | truncate | a.remainder(b) |
| --- | --- | ---- | ----- | ----- | -------- | -------------- |
| 17  | 5   | 3.4  | 3     | 2     | 3        | 2              |
| 17  | -5  | -3.4 | -4    | -3    | -3       | 2              |
| -17 | 5   | -3.4 | -4    | 3     | -3       | -2             |
| -17 | -5  | 3.4  | 3     | -2    | 3        | -2             |

Ruby Docs:
a % b = a-(b*(a/b).floor)
a.remainder(b) = a % b = a-(b*(a/b).truncate)

#### .to_i(base=10)

`string.to_i(b)` assumes the string is in base b and converts it to a base 10 integer

Returns first valid base b number in string or 0

    "0a".to_i(16)  # => 10
    "4 hello".to_i # => 4
    "hello 4".to_i # => 0

Same for .to_f(base=10) for float conversion

#### .gets.chomp

`.gets` equivalent to python `input()`

- always returns input + \n
  `chomp` equivalent to python `.strip()`
